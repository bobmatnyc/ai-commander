//! Tool calling types for agent function execution.
//!
//! This module defines the types used for tool definitions, calls, and results
//! that enable agents to execute structured function calls.

use serde::{Deserialize, Serialize};

/// Definition of a tool that an agent can use.
///
/// Tools are functions that agents can call to perform actions or retrieve
/// information. Each tool has a name, description, and JSON Schema for its
/// parameters.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolDefinition {
    /// Unique name of the tool (e.g., "read_file", "search_web").
    pub name: String,

    /// Human-readable description of what the tool does.
    /// Used by the LLM to decide when to use this tool.
    pub description: String,

    /// JSON Schema describing the tool's parameters.
    /// This follows the OpenAPI/JSON Schema specification.
    pub parameters: serde_json::Value,
}

impl ToolDefinition {
    /// Create a new tool definition.
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        parameters: serde_json::Value,
    ) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            parameters,
        }
    }

    /// Create a tool definition with no parameters.
    pub fn no_params(name: impl Into<String>, description: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            parameters: serde_json::json!({
                "type": "object",
                "properties": {},
                "required": []
            }),
        }
    }
}

/// A request to execute a tool with specific arguments.
///
/// Tool calls are generated by the LLM when it determines that a tool should
/// be used to complete a task.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCall {
    /// Unique identifier for this tool call.
    /// Used to correlate results back to the original call.
    pub id: String,

    /// Name of the tool to execute (must match a ToolDefinition name).
    pub name: String,

    /// Arguments to pass to the tool (must match the tool's parameter schema).
    pub arguments: serde_json::Value,
}

impl ToolCall {
    /// Create a new tool call with a generated ID.
    pub fn new(name: impl Into<String>, arguments: serde_json::Value) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.into(),
            arguments,
        }
    }

    /// Create a new tool call with a specific ID.
    pub fn with_id(
        id: impl Into<String>,
        name: impl Into<String>,
        arguments: serde_json::Value,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            arguments,
        }
    }

    /// Get an argument value by key.
    pub fn get_arg(&self, key: &str) -> Option<&serde_json::Value> {
        self.arguments.get(key)
    }

    /// Get a string argument, returning an error if not found or not a string.
    pub fn get_string_arg(&self, key: &str) -> Result<&str, String> {
        self.arguments
            .get(key)
            .and_then(|v| v.as_str())
            .ok_or_else(|| format!("missing or invalid string argument: {}", key))
    }

    /// Get an optional string argument.
    pub fn get_optional_string_arg(&self, key: &str) -> Option<&str> {
        self.arguments.get(key).and_then(|v| v.as_str())
    }
}

/// Result of executing a tool call.
///
/// Contains the output (or error message) from tool execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResult {
    /// ID of the tool call this result corresponds to.
    pub tool_call_id: String,

    /// Output content from the tool execution.
    /// For successful calls, this is the tool's output.
    /// For failed calls, this is the error message.
    pub content: String,

    /// Whether the tool execution resulted in an error.
    pub is_error: bool,
}

impl ToolResult {
    /// Create a successful tool result.
    pub fn success(tool_call_id: impl Into<String>, content: impl Into<String>) -> Self {
        Self {
            tool_call_id: tool_call_id.into(),
            content: content.into(),
            is_error: false,
        }
    }

    /// Create an error tool result.
    pub fn error(tool_call_id: impl Into<String>, error: impl Into<String>) -> Self {
        Self {
            tool_call_id: tool_call_id.into(),
            content: error.into(),
            is_error: true,
        }
    }

    /// Create a result from a Result type.
    pub fn from_result<T: ToString, E: ToString>(
        tool_call_id: impl Into<String>,
        result: Result<T, E>,
    ) -> Self {
        match result {
            Ok(value) => Self::success(tool_call_id, value.to_string()),
            Err(err) => Self::error(tool_call_id, err.to_string()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_tool_definition() {
        let tool = ToolDefinition::new(
            "read_file",
            "Read contents of a file",
            json!({
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "Path to the file"
                    }
                },
                "required": ["path"]
            }),
        );

        assert_eq!(tool.name, "read_file");
        assert_eq!(tool.description, "Read contents of a file");
    }

    #[test]
    fn test_tool_definition_no_params() {
        let tool = ToolDefinition::no_params("get_time", "Get the current time");

        assert_eq!(tool.name, "get_time");
        assert_eq!(tool.parameters["type"], "object");
        assert!(tool.parameters["properties"].as_object().unwrap().is_empty());
    }

    #[test]
    fn test_tool_call() {
        let call = ToolCall::new(
            "read_file",
            json!({
                "path": "/tmp/test.txt"
            }),
        );

        assert!(!call.id.is_empty());
        assert_eq!(call.name, "read_file");
        assert_eq!(call.get_string_arg("path").unwrap(), "/tmp/test.txt");
    }

    #[test]
    fn test_tool_call_with_id() {
        let call = ToolCall::with_id(
            "call-123",
            "read_file",
            json!({ "path": "/tmp/test.txt" }),
        );

        assert_eq!(call.id, "call-123");
    }

    #[test]
    fn test_tool_call_get_args() {
        let call = ToolCall::new(
            "test",
            json!({
                "required": "value",
                "number": 42
            }),
        );

        // get_arg
        assert_eq!(call.get_arg("required"), Some(&json!("value")));
        assert_eq!(call.get_arg("missing"), None);

        // get_string_arg
        assert_eq!(call.get_string_arg("required").unwrap(), "value");
        assert!(call.get_string_arg("missing").is_err());
        assert!(call.get_string_arg("number").is_err()); // Not a string

        // get_optional_string_arg
        assert_eq!(call.get_optional_string_arg("required"), Some("value"));
        assert_eq!(call.get_optional_string_arg("missing"), None);
    }

    #[test]
    fn test_tool_result_success() {
        let result = ToolResult::success("call-123", "File contents here");

        assert_eq!(result.tool_call_id, "call-123");
        assert_eq!(result.content, "File contents here");
        assert!(!result.is_error);
    }

    #[test]
    fn test_tool_result_error() {
        let result = ToolResult::error("call-123", "File not found");

        assert_eq!(result.tool_call_id, "call-123");
        assert_eq!(result.content, "File not found");
        assert!(result.is_error);
    }

    #[test]
    fn test_tool_result_from_result() {
        let ok_result: Result<&str, &str> = Ok("success");
        let result = ToolResult::from_result("call-1", ok_result);
        assert!(!result.is_error);
        assert_eq!(result.content, "success");

        let err_result: Result<&str, &str> = Err("failed");
        let result = ToolResult::from_result("call-2", err_result);
        assert!(result.is_error);
        assert_eq!(result.content, "failed");
    }

    #[test]
    fn test_serialization() {
        let call = ToolCall::with_id("call-123", "test", json!({"key": "value"}));
        let json = serde_json::to_string(&call).unwrap();
        let parsed: ToolCall = serde_json::from_str(&json).unwrap();

        assert_eq!(call.id, parsed.id);
        assert_eq!(call.name, parsed.name);
        assert_eq!(call.arguments, parsed.arguments);

        let result = ToolResult::success("call-123", "output");
        let json = serde_json::to_string(&result).unwrap();
        let parsed: ToolResult = serde_json::from_str(&json).unwrap();

        assert_eq!(result.tool_call_id, parsed.tool_call_id);
        assert_eq!(result.content, parsed.content);
        assert_eq!(result.is_error, parsed.is_error);
    }
}
